// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'instruction_type.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$InstructionTypeTearOff {
  const _$InstructionTypeTearOff();

// ignore: unused_element
  _Left left() {
    return const _Left();
  }

// ignore: unused_element
  _Right right() {
    return const _Right();
  }

// ignore: unused_element
  _SharpLeft sharpLeft() {
    return const _SharpLeft();
  }

// ignore: unused_element
  _SharpRight sharpRight() {
    return const _SharpRight();
  }

// ignore: unused_element
  _SlightLeft slightLeft() {
    return const _SlightLeft();
  }

// ignore: unused_element
  _SlightRight slightRight() {
    return const _SlightRight();
  }

// ignore: unused_element
  _Straight straight() {
    return const _Straight();
  }

// ignore: unused_element
  _EnterRoundabout enterRoundabout() {
    return const _EnterRoundabout();
  }

// ignore: unused_element
  _ExitRoundabout exitRoundabout() {
    return const _ExitRoundabout();
  }

// ignore: unused_element
  _UTurn uTurn() {
    return const _UTurn();
  }

// ignore: unused_element
  _Goal goal() {
    return const _Goal();
  }

// ignore: unused_element
  _Depart depart() {
    return const _Depart();
  }

// ignore: unused_element
  _KeepLeft keepLeft() {
    return const _KeepLeft();
  }

// ignore: unused_element
  _KeepRight keepRight() {
    return const _KeepRight();
  }
}

/// @nodoc
// ignore: unused_element
const $InstructionType = _$InstructionTypeTearOff();

/// @nodoc
mixin _$InstructionType {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result left(),
    @required Result right(),
    @required Result sharpLeft(),
    @required Result sharpRight(),
    @required Result slightLeft(),
    @required Result slightRight(),
    @required Result straight(),
    @required Result enterRoundabout(),
    @required Result exitRoundabout(),
    @required Result uTurn(),
    @required Result goal(),
    @required Result depart(),
    @required Result keepLeft(),
    @required Result keepRight(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result left(),
    Result right(),
    Result sharpLeft(),
    Result sharpRight(),
    Result slightLeft(),
    Result slightRight(),
    Result straight(),
    Result enterRoundabout(),
    Result exitRoundabout(),
    Result uTurn(),
    Result goal(),
    Result depart(),
    Result keepLeft(),
    Result keepRight(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result left(_Left value),
    @required Result right(_Right value),
    @required Result sharpLeft(_SharpLeft value),
    @required Result sharpRight(_SharpRight value),
    @required Result slightLeft(_SlightLeft value),
    @required Result slightRight(_SlightRight value),
    @required Result straight(_Straight value),
    @required Result enterRoundabout(_EnterRoundabout value),
    @required Result exitRoundabout(_ExitRoundabout value),
    @required Result uTurn(_UTurn value),
    @required Result goal(_Goal value),
    @required Result depart(_Depart value),
    @required Result keepLeft(_KeepLeft value),
    @required Result keepRight(_KeepRight value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result left(_Left value),
    Result right(_Right value),
    Result sharpLeft(_SharpLeft value),
    Result sharpRight(_SharpRight value),
    Result slightLeft(_SlightLeft value),
    Result slightRight(_SlightRight value),
    Result straight(_Straight value),
    Result enterRoundabout(_EnterRoundabout value),
    Result exitRoundabout(_ExitRoundabout value),
    Result uTurn(_UTurn value),
    Result goal(_Goal value),
    Result depart(_Depart value),
    Result keepLeft(_KeepLeft value),
    Result keepRight(_KeepRight value),
    @required Result orElse(),
  });
}

/// @nodoc
abstract class $InstructionTypeCopyWith<$Res> {
  factory $InstructionTypeCopyWith(
          InstructionType value, $Res Function(InstructionType) then) =
      _$InstructionTypeCopyWithImpl<$Res>;
}

/// @nodoc
class _$InstructionTypeCopyWithImpl<$Res>
    implements $InstructionTypeCopyWith<$Res> {
  _$InstructionTypeCopyWithImpl(this._value, this._then);

  final InstructionType _value;
  // ignore: unused_field
  final $Res Function(InstructionType) _then;
}

/// @nodoc
abstract class _$LeftCopyWith<$Res> {
  factory _$LeftCopyWith(_Left value, $Res Function(_Left) then) =
      __$LeftCopyWithImpl<$Res>;
}

/// @nodoc
class __$LeftCopyWithImpl<$Res> extends _$InstructionTypeCopyWithImpl<$Res>
    implements _$LeftCopyWith<$Res> {
  __$LeftCopyWithImpl(_Left _value, $Res Function(_Left) _then)
      : super(_value, (v) => _then(v as _Left));

  @override
  _Left get _value => super._value as _Left;
}

/// @nodoc
class _$_Left implements _Left {
  const _$_Left();

  @override
  String toString() {
    return 'InstructionType.left()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Left);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result left(),
    @required Result right(),
    @required Result sharpLeft(),
    @required Result sharpRight(),
    @required Result slightLeft(),
    @required Result slightRight(),
    @required Result straight(),
    @required Result enterRoundabout(),
    @required Result exitRoundabout(),
    @required Result uTurn(),
    @required Result goal(),
    @required Result depart(),
    @required Result keepLeft(),
    @required Result keepRight(),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return left();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result left(),
    Result right(),
    Result sharpLeft(),
    Result sharpRight(),
    Result slightLeft(),
    Result slightRight(),
    Result straight(),
    Result enterRoundabout(),
    Result exitRoundabout(),
    Result uTurn(),
    Result goal(),
    Result depart(),
    Result keepLeft(),
    Result keepRight(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (left != null) {
      return left();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result left(_Left value),
    @required Result right(_Right value),
    @required Result sharpLeft(_SharpLeft value),
    @required Result sharpRight(_SharpRight value),
    @required Result slightLeft(_SlightLeft value),
    @required Result slightRight(_SlightRight value),
    @required Result straight(_Straight value),
    @required Result enterRoundabout(_EnterRoundabout value),
    @required Result exitRoundabout(_ExitRoundabout value),
    @required Result uTurn(_UTurn value),
    @required Result goal(_Goal value),
    @required Result depart(_Depart value),
    @required Result keepLeft(_KeepLeft value),
    @required Result keepRight(_KeepRight value),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return left(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result left(_Left value),
    Result right(_Right value),
    Result sharpLeft(_SharpLeft value),
    Result sharpRight(_SharpRight value),
    Result slightLeft(_SlightLeft value),
    Result slightRight(_SlightRight value),
    Result straight(_Straight value),
    Result enterRoundabout(_EnterRoundabout value),
    Result exitRoundabout(_ExitRoundabout value),
    Result uTurn(_UTurn value),
    Result goal(_Goal value),
    Result depart(_Depart value),
    Result keepLeft(_KeepLeft value),
    Result keepRight(_KeepRight value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (left != null) {
      return left(this);
    }
    return orElse();
  }
}

abstract class _Left implements InstructionType {
  const factory _Left() = _$_Left;
}

/// @nodoc
abstract class _$RightCopyWith<$Res> {
  factory _$RightCopyWith(_Right value, $Res Function(_Right) then) =
      __$RightCopyWithImpl<$Res>;
}

/// @nodoc
class __$RightCopyWithImpl<$Res> extends _$InstructionTypeCopyWithImpl<$Res>
    implements _$RightCopyWith<$Res> {
  __$RightCopyWithImpl(_Right _value, $Res Function(_Right) _then)
      : super(_value, (v) => _then(v as _Right));

  @override
  _Right get _value => super._value as _Right;
}

/// @nodoc
class _$_Right implements _Right {
  const _$_Right();

  @override
  String toString() {
    return 'InstructionType.right()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Right);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result left(),
    @required Result right(),
    @required Result sharpLeft(),
    @required Result sharpRight(),
    @required Result slightLeft(),
    @required Result slightRight(),
    @required Result straight(),
    @required Result enterRoundabout(),
    @required Result exitRoundabout(),
    @required Result uTurn(),
    @required Result goal(),
    @required Result depart(),
    @required Result keepLeft(),
    @required Result keepRight(),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return right();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result left(),
    Result right(),
    Result sharpLeft(),
    Result sharpRight(),
    Result slightLeft(),
    Result slightRight(),
    Result straight(),
    Result enterRoundabout(),
    Result exitRoundabout(),
    Result uTurn(),
    Result goal(),
    Result depart(),
    Result keepLeft(),
    Result keepRight(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (right != null) {
      return right();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result left(_Left value),
    @required Result right(_Right value),
    @required Result sharpLeft(_SharpLeft value),
    @required Result sharpRight(_SharpRight value),
    @required Result slightLeft(_SlightLeft value),
    @required Result slightRight(_SlightRight value),
    @required Result straight(_Straight value),
    @required Result enterRoundabout(_EnterRoundabout value),
    @required Result exitRoundabout(_ExitRoundabout value),
    @required Result uTurn(_UTurn value),
    @required Result goal(_Goal value),
    @required Result depart(_Depart value),
    @required Result keepLeft(_KeepLeft value),
    @required Result keepRight(_KeepRight value),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return right(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result left(_Left value),
    Result right(_Right value),
    Result sharpLeft(_SharpLeft value),
    Result sharpRight(_SharpRight value),
    Result slightLeft(_SlightLeft value),
    Result slightRight(_SlightRight value),
    Result straight(_Straight value),
    Result enterRoundabout(_EnterRoundabout value),
    Result exitRoundabout(_ExitRoundabout value),
    Result uTurn(_UTurn value),
    Result goal(_Goal value),
    Result depart(_Depart value),
    Result keepLeft(_KeepLeft value),
    Result keepRight(_KeepRight value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (right != null) {
      return right(this);
    }
    return orElse();
  }
}

abstract class _Right implements InstructionType {
  const factory _Right() = _$_Right;
}

/// @nodoc
abstract class _$SharpLeftCopyWith<$Res> {
  factory _$SharpLeftCopyWith(
          _SharpLeft value, $Res Function(_SharpLeft) then) =
      __$SharpLeftCopyWithImpl<$Res>;
}

/// @nodoc
class __$SharpLeftCopyWithImpl<$Res> extends _$InstructionTypeCopyWithImpl<$Res>
    implements _$SharpLeftCopyWith<$Res> {
  __$SharpLeftCopyWithImpl(_SharpLeft _value, $Res Function(_SharpLeft) _then)
      : super(_value, (v) => _then(v as _SharpLeft));

  @override
  _SharpLeft get _value => super._value as _SharpLeft;
}

/// @nodoc
class _$_SharpLeft implements _SharpLeft {
  const _$_SharpLeft();

  @override
  String toString() {
    return 'InstructionType.sharpLeft()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _SharpLeft);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result left(),
    @required Result right(),
    @required Result sharpLeft(),
    @required Result sharpRight(),
    @required Result slightLeft(),
    @required Result slightRight(),
    @required Result straight(),
    @required Result enterRoundabout(),
    @required Result exitRoundabout(),
    @required Result uTurn(),
    @required Result goal(),
    @required Result depart(),
    @required Result keepLeft(),
    @required Result keepRight(),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return sharpLeft();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result left(),
    Result right(),
    Result sharpLeft(),
    Result sharpRight(),
    Result slightLeft(),
    Result slightRight(),
    Result straight(),
    Result enterRoundabout(),
    Result exitRoundabout(),
    Result uTurn(),
    Result goal(),
    Result depart(),
    Result keepLeft(),
    Result keepRight(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (sharpLeft != null) {
      return sharpLeft();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result left(_Left value),
    @required Result right(_Right value),
    @required Result sharpLeft(_SharpLeft value),
    @required Result sharpRight(_SharpRight value),
    @required Result slightLeft(_SlightLeft value),
    @required Result slightRight(_SlightRight value),
    @required Result straight(_Straight value),
    @required Result enterRoundabout(_EnterRoundabout value),
    @required Result exitRoundabout(_ExitRoundabout value),
    @required Result uTurn(_UTurn value),
    @required Result goal(_Goal value),
    @required Result depart(_Depart value),
    @required Result keepLeft(_KeepLeft value),
    @required Result keepRight(_KeepRight value),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return sharpLeft(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result left(_Left value),
    Result right(_Right value),
    Result sharpLeft(_SharpLeft value),
    Result sharpRight(_SharpRight value),
    Result slightLeft(_SlightLeft value),
    Result slightRight(_SlightRight value),
    Result straight(_Straight value),
    Result enterRoundabout(_EnterRoundabout value),
    Result exitRoundabout(_ExitRoundabout value),
    Result uTurn(_UTurn value),
    Result goal(_Goal value),
    Result depart(_Depart value),
    Result keepLeft(_KeepLeft value),
    Result keepRight(_KeepRight value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (sharpLeft != null) {
      return sharpLeft(this);
    }
    return orElse();
  }
}

abstract class _SharpLeft implements InstructionType {
  const factory _SharpLeft() = _$_SharpLeft;
}

/// @nodoc
abstract class _$SharpRightCopyWith<$Res> {
  factory _$SharpRightCopyWith(
          _SharpRight value, $Res Function(_SharpRight) then) =
      __$SharpRightCopyWithImpl<$Res>;
}

/// @nodoc
class __$SharpRightCopyWithImpl<$Res>
    extends _$InstructionTypeCopyWithImpl<$Res>
    implements _$SharpRightCopyWith<$Res> {
  __$SharpRightCopyWithImpl(
      _SharpRight _value, $Res Function(_SharpRight) _then)
      : super(_value, (v) => _then(v as _SharpRight));

  @override
  _SharpRight get _value => super._value as _SharpRight;
}

/// @nodoc
class _$_SharpRight implements _SharpRight {
  const _$_SharpRight();

  @override
  String toString() {
    return 'InstructionType.sharpRight()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _SharpRight);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result left(),
    @required Result right(),
    @required Result sharpLeft(),
    @required Result sharpRight(),
    @required Result slightLeft(),
    @required Result slightRight(),
    @required Result straight(),
    @required Result enterRoundabout(),
    @required Result exitRoundabout(),
    @required Result uTurn(),
    @required Result goal(),
    @required Result depart(),
    @required Result keepLeft(),
    @required Result keepRight(),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return sharpRight();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result left(),
    Result right(),
    Result sharpLeft(),
    Result sharpRight(),
    Result slightLeft(),
    Result slightRight(),
    Result straight(),
    Result enterRoundabout(),
    Result exitRoundabout(),
    Result uTurn(),
    Result goal(),
    Result depart(),
    Result keepLeft(),
    Result keepRight(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (sharpRight != null) {
      return sharpRight();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result left(_Left value),
    @required Result right(_Right value),
    @required Result sharpLeft(_SharpLeft value),
    @required Result sharpRight(_SharpRight value),
    @required Result slightLeft(_SlightLeft value),
    @required Result slightRight(_SlightRight value),
    @required Result straight(_Straight value),
    @required Result enterRoundabout(_EnterRoundabout value),
    @required Result exitRoundabout(_ExitRoundabout value),
    @required Result uTurn(_UTurn value),
    @required Result goal(_Goal value),
    @required Result depart(_Depart value),
    @required Result keepLeft(_KeepLeft value),
    @required Result keepRight(_KeepRight value),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return sharpRight(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result left(_Left value),
    Result right(_Right value),
    Result sharpLeft(_SharpLeft value),
    Result sharpRight(_SharpRight value),
    Result slightLeft(_SlightLeft value),
    Result slightRight(_SlightRight value),
    Result straight(_Straight value),
    Result enterRoundabout(_EnterRoundabout value),
    Result exitRoundabout(_ExitRoundabout value),
    Result uTurn(_UTurn value),
    Result goal(_Goal value),
    Result depart(_Depart value),
    Result keepLeft(_KeepLeft value),
    Result keepRight(_KeepRight value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (sharpRight != null) {
      return sharpRight(this);
    }
    return orElse();
  }
}

abstract class _SharpRight implements InstructionType {
  const factory _SharpRight() = _$_SharpRight;
}

/// @nodoc
abstract class _$SlightLeftCopyWith<$Res> {
  factory _$SlightLeftCopyWith(
          _SlightLeft value, $Res Function(_SlightLeft) then) =
      __$SlightLeftCopyWithImpl<$Res>;
}

/// @nodoc
class __$SlightLeftCopyWithImpl<$Res>
    extends _$InstructionTypeCopyWithImpl<$Res>
    implements _$SlightLeftCopyWith<$Res> {
  __$SlightLeftCopyWithImpl(
      _SlightLeft _value, $Res Function(_SlightLeft) _then)
      : super(_value, (v) => _then(v as _SlightLeft));

  @override
  _SlightLeft get _value => super._value as _SlightLeft;
}

/// @nodoc
class _$_SlightLeft implements _SlightLeft {
  const _$_SlightLeft();

  @override
  String toString() {
    return 'InstructionType.slightLeft()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _SlightLeft);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result left(),
    @required Result right(),
    @required Result sharpLeft(),
    @required Result sharpRight(),
    @required Result slightLeft(),
    @required Result slightRight(),
    @required Result straight(),
    @required Result enterRoundabout(),
    @required Result exitRoundabout(),
    @required Result uTurn(),
    @required Result goal(),
    @required Result depart(),
    @required Result keepLeft(),
    @required Result keepRight(),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return slightLeft();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result left(),
    Result right(),
    Result sharpLeft(),
    Result sharpRight(),
    Result slightLeft(),
    Result slightRight(),
    Result straight(),
    Result enterRoundabout(),
    Result exitRoundabout(),
    Result uTurn(),
    Result goal(),
    Result depart(),
    Result keepLeft(),
    Result keepRight(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (slightLeft != null) {
      return slightLeft();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result left(_Left value),
    @required Result right(_Right value),
    @required Result sharpLeft(_SharpLeft value),
    @required Result sharpRight(_SharpRight value),
    @required Result slightLeft(_SlightLeft value),
    @required Result slightRight(_SlightRight value),
    @required Result straight(_Straight value),
    @required Result enterRoundabout(_EnterRoundabout value),
    @required Result exitRoundabout(_ExitRoundabout value),
    @required Result uTurn(_UTurn value),
    @required Result goal(_Goal value),
    @required Result depart(_Depart value),
    @required Result keepLeft(_KeepLeft value),
    @required Result keepRight(_KeepRight value),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return slightLeft(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result left(_Left value),
    Result right(_Right value),
    Result sharpLeft(_SharpLeft value),
    Result sharpRight(_SharpRight value),
    Result slightLeft(_SlightLeft value),
    Result slightRight(_SlightRight value),
    Result straight(_Straight value),
    Result enterRoundabout(_EnterRoundabout value),
    Result exitRoundabout(_ExitRoundabout value),
    Result uTurn(_UTurn value),
    Result goal(_Goal value),
    Result depart(_Depart value),
    Result keepLeft(_KeepLeft value),
    Result keepRight(_KeepRight value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (slightLeft != null) {
      return slightLeft(this);
    }
    return orElse();
  }
}

abstract class _SlightLeft implements InstructionType {
  const factory _SlightLeft() = _$_SlightLeft;
}

/// @nodoc
abstract class _$SlightRightCopyWith<$Res> {
  factory _$SlightRightCopyWith(
          _SlightRight value, $Res Function(_SlightRight) then) =
      __$SlightRightCopyWithImpl<$Res>;
}

/// @nodoc
class __$SlightRightCopyWithImpl<$Res>
    extends _$InstructionTypeCopyWithImpl<$Res>
    implements _$SlightRightCopyWith<$Res> {
  __$SlightRightCopyWithImpl(
      _SlightRight _value, $Res Function(_SlightRight) _then)
      : super(_value, (v) => _then(v as _SlightRight));

  @override
  _SlightRight get _value => super._value as _SlightRight;
}

/// @nodoc
class _$_SlightRight implements _SlightRight {
  const _$_SlightRight();

  @override
  String toString() {
    return 'InstructionType.slightRight()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _SlightRight);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result left(),
    @required Result right(),
    @required Result sharpLeft(),
    @required Result sharpRight(),
    @required Result slightLeft(),
    @required Result slightRight(),
    @required Result straight(),
    @required Result enterRoundabout(),
    @required Result exitRoundabout(),
    @required Result uTurn(),
    @required Result goal(),
    @required Result depart(),
    @required Result keepLeft(),
    @required Result keepRight(),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return slightRight();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result left(),
    Result right(),
    Result sharpLeft(),
    Result sharpRight(),
    Result slightLeft(),
    Result slightRight(),
    Result straight(),
    Result enterRoundabout(),
    Result exitRoundabout(),
    Result uTurn(),
    Result goal(),
    Result depart(),
    Result keepLeft(),
    Result keepRight(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (slightRight != null) {
      return slightRight();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result left(_Left value),
    @required Result right(_Right value),
    @required Result sharpLeft(_SharpLeft value),
    @required Result sharpRight(_SharpRight value),
    @required Result slightLeft(_SlightLeft value),
    @required Result slightRight(_SlightRight value),
    @required Result straight(_Straight value),
    @required Result enterRoundabout(_EnterRoundabout value),
    @required Result exitRoundabout(_ExitRoundabout value),
    @required Result uTurn(_UTurn value),
    @required Result goal(_Goal value),
    @required Result depart(_Depart value),
    @required Result keepLeft(_KeepLeft value),
    @required Result keepRight(_KeepRight value),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return slightRight(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result left(_Left value),
    Result right(_Right value),
    Result sharpLeft(_SharpLeft value),
    Result sharpRight(_SharpRight value),
    Result slightLeft(_SlightLeft value),
    Result slightRight(_SlightRight value),
    Result straight(_Straight value),
    Result enterRoundabout(_EnterRoundabout value),
    Result exitRoundabout(_ExitRoundabout value),
    Result uTurn(_UTurn value),
    Result goal(_Goal value),
    Result depart(_Depart value),
    Result keepLeft(_KeepLeft value),
    Result keepRight(_KeepRight value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (slightRight != null) {
      return slightRight(this);
    }
    return orElse();
  }
}

abstract class _SlightRight implements InstructionType {
  const factory _SlightRight() = _$_SlightRight;
}

/// @nodoc
abstract class _$StraightCopyWith<$Res> {
  factory _$StraightCopyWith(_Straight value, $Res Function(_Straight) then) =
      __$StraightCopyWithImpl<$Res>;
}

/// @nodoc
class __$StraightCopyWithImpl<$Res> extends _$InstructionTypeCopyWithImpl<$Res>
    implements _$StraightCopyWith<$Res> {
  __$StraightCopyWithImpl(_Straight _value, $Res Function(_Straight) _then)
      : super(_value, (v) => _then(v as _Straight));

  @override
  _Straight get _value => super._value as _Straight;
}

/// @nodoc
class _$_Straight implements _Straight {
  const _$_Straight();

  @override
  String toString() {
    return 'InstructionType.straight()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Straight);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result left(),
    @required Result right(),
    @required Result sharpLeft(),
    @required Result sharpRight(),
    @required Result slightLeft(),
    @required Result slightRight(),
    @required Result straight(),
    @required Result enterRoundabout(),
    @required Result exitRoundabout(),
    @required Result uTurn(),
    @required Result goal(),
    @required Result depart(),
    @required Result keepLeft(),
    @required Result keepRight(),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return straight();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result left(),
    Result right(),
    Result sharpLeft(),
    Result sharpRight(),
    Result slightLeft(),
    Result slightRight(),
    Result straight(),
    Result enterRoundabout(),
    Result exitRoundabout(),
    Result uTurn(),
    Result goal(),
    Result depart(),
    Result keepLeft(),
    Result keepRight(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (straight != null) {
      return straight();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result left(_Left value),
    @required Result right(_Right value),
    @required Result sharpLeft(_SharpLeft value),
    @required Result sharpRight(_SharpRight value),
    @required Result slightLeft(_SlightLeft value),
    @required Result slightRight(_SlightRight value),
    @required Result straight(_Straight value),
    @required Result enterRoundabout(_EnterRoundabout value),
    @required Result exitRoundabout(_ExitRoundabout value),
    @required Result uTurn(_UTurn value),
    @required Result goal(_Goal value),
    @required Result depart(_Depart value),
    @required Result keepLeft(_KeepLeft value),
    @required Result keepRight(_KeepRight value),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return straight(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result left(_Left value),
    Result right(_Right value),
    Result sharpLeft(_SharpLeft value),
    Result sharpRight(_SharpRight value),
    Result slightLeft(_SlightLeft value),
    Result slightRight(_SlightRight value),
    Result straight(_Straight value),
    Result enterRoundabout(_EnterRoundabout value),
    Result exitRoundabout(_ExitRoundabout value),
    Result uTurn(_UTurn value),
    Result goal(_Goal value),
    Result depart(_Depart value),
    Result keepLeft(_KeepLeft value),
    Result keepRight(_KeepRight value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (straight != null) {
      return straight(this);
    }
    return orElse();
  }
}

abstract class _Straight implements InstructionType {
  const factory _Straight() = _$_Straight;
}

/// @nodoc
abstract class _$EnterRoundaboutCopyWith<$Res> {
  factory _$EnterRoundaboutCopyWith(
          _EnterRoundabout value, $Res Function(_EnterRoundabout) then) =
      __$EnterRoundaboutCopyWithImpl<$Res>;
}

/// @nodoc
class __$EnterRoundaboutCopyWithImpl<$Res>
    extends _$InstructionTypeCopyWithImpl<$Res>
    implements _$EnterRoundaboutCopyWith<$Res> {
  __$EnterRoundaboutCopyWithImpl(
      _EnterRoundabout _value, $Res Function(_EnterRoundabout) _then)
      : super(_value, (v) => _then(v as _EnterRoundabout));

  @override
  _EnterRoundabout get _value => super._value as _EnterRoundabout;
}

/// @nodoc
class _$_EnterRoundabout implements _EnterRoundabout {
  const _$_EnterRoundabout();

  @override
  String toString() {
    return 'InstructionType.enterRoundabout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _EnterRoundabout);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result left(),
    @required Result right(),
    @required Result sharpLeft(),
    @required Result sharpRight(),
    @required Result slightLeft(),
    @required Result slightRight(),
    @required Result straight(),
    @required Result enterRoundabout(),
    @required Result exitRoundabout(),
    @required Result uTurn(),
    @required Result goal(),
    @required Result depart(),
    @required Result keepLeft(),
    @required Result keepRight(),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return enterRoundabout();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result left(),
    Result right(),
    Result sharpLeft(),
    Result sharpRight(),
    Result slightLeft(),
    Result slightRight(),
    Result straight(),
    Result enterRoundabout(),
    Result exitRoundabout(),
    Result uTurn(),
    Result goal(),
    Result depart(),
    Result keepLeft(),
    Result keepRight(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (enterRoundabout != null) {
      return enterRoundabout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result left(_Left value),
    @required Result right(_Right value),
    @required Result sharpLeft(_SharpLeft value),
    @required Result sharpRight(_SharpRight value),
    @required Result slightLeft(_SlightLeft value),
    @required Result slightRight(_SlightRight value),
    @required Result straight(_Straight value),
    @required Result enterRoundabout(_EnterRoundabout value),
    @required Result exitRoundabout(_ExitRoundabout value),
    @required Result uTurn(_UTurn value),
    @required Result goal(_Goal value),
    @required Result depart(_Depart value),
    @required Result keepLeft(_KeepLeft value),
    @required Result keepRight(_KeepRight value),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return enterRoundabout(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result left(_Left value),
    Result right(_Right value),
    Result sharpLeft(_SharpLeft value),
    Result sharpRight(_SharpRight value),
    Result slightLeft(_SlightLeft value),
    Result slightRight(_SlightRight value),
    Result straight(_Straight value),
    Result enterRoundabout(_EnterRoundabout value),
    Result exitRoundabout(_ExitRoundabout value),
    Result uTurn(_UTurn value),
    Result goal(_Goal value),
    Result depart(_Depart value),
    Result keepLeft(_KeepLeft value),
    Result keepRight(_KeepRight value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (enterRoundabout != null) {
      return enterRoundabout(this);
    }
    return orElse();
  }
}

abstract class _EnterRoundabout implements InstructionType {
  const factory _EnterRoundabout() = _$_EnterRoundabout;
}

/// @nodoc
abstract class _$ExitRoundaboutCopyWith<$Res> {
  factory _$ExitRoundaboutCopyWith(
          _ExitRoundabout value, $Res Function(_ExitRoundabout) then) =
      __$ExitRoundaboutCopyWithImpl<$Res>;
}

/// @nodoc
class __$ExitRoundaboutCopyWithImpl<$Res>
    extends _$InstructionTypeCopyWithImpl<$Res>
    implements _$ExitRoundaboutCopyWith<$Res> {
  __$ExitRoundaboutCopyWithImpl(
      _ExitRoundabout _value, $Res Function(_ExitRoundabout) _then)
      : super(_value, (v) => _then(v as _ExitRoundabout));

  @override
  _ExitRoundabout get _value => super._value as _ExitRoundabout;
}

/// @nodoc
class _$_ExitRoundabout implements _ExitRoundabout {
  const _$_ExitRoundabout();

  @override
  String toString() {
    return 'InstructionType.exitRoundabout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ExitRoundabout);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result left(),
    @required Result right(),
    @required Result sharpLeft(),
    @required Result sharpRight(),
    @required Result slightLeft(),
    @required Result slightRight(),
    @required Result straight(),
    @required Result enterRoundabout(),
    @required Result exitRoundabout(),
    @required Result uTurn(),
    @required Result goal(),
    @required Result depart(),
    @required Result keepLeft(),
    @required Result keepRight(),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return exitRoundabout();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result left(),
    Result right(),
    Result sharpLeft(),
    Result sharpRight(),
    Result slightLeft(),
    Result slightRight(),
    Result straight(),
    Result enterRoundabout(),
    Result exitRoundabout(),
    Result uTurn(),
    Result goal(),
    Result depart(),
    Result keepLeft(),
    Result keepRight(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (exitRoundabout != null) {
      return exitRoundabout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result left(_Left value),
    @required Result right(_Right value),
    @required Result sharpLeft(_SharpLeft value),
    @required Result sharpRight(_SharpRight value),
    @required Result slightLeft(_SlightLeft value),
    @required Result slightRight(_SlightRight value),
    @required Result straight(_Straight value),
    @required Result enterRoundabout(_EnterRoundabout value),
    @required Result exitRoundabout(_ExitRoundabout value),
    @required Result uTurn(_UTurn value),
    @required Result goal(_Goal value),
    @required Result depart(_Depart value),
    @required Result keepLeft(_KeepLeft value),
    @required Result keepRight(_KeepRight value),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return exitRoundabout(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result left(_Left value),
    Result right(_Right value),
    Result sharpLeft(_SharpLeft value),
    Result sharpRight(_SharpRight value),
    Result slightLeft(_SlightLeft value),
    Result slightRight(_SlightRight value),
    Result straight(_Straight value),
    Result enterRoundabout(_EnterRoundabout value),
    Result exitRoundabout(_ExitRoundabout value),
    Result uTurn(_UTurn value),
    Result goal(_Goal value),
    Result depart(_Depart value),
    Result keepLeft(_KeepLeft value),
    Result keepRight(_KeepRight value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (exitRoundabout != null) {
      return exitRoundabout(this);
    }
    return orElse();
  }
}

abstract class _ExitRoundabout implements InstructionType {
  const factory _ExitRoundabout() = _$_ExitRoundabout;
}

/// @nodoc
abstract class _$UTurnCopyWith<$Res> {
  factory _$UTurnCopyWith(_UTurn value, $Res Function(_UTurn) then) =
      __$UTurnCopyWithImpl<$Res>;
}

/// @nodoc
class __$UTurnCopyWithImpl<$Res> extends _$InstructionTypeCopyWithImpl<$Res>
    implements _$UTurnCopyWith<$Res> {
  __$UTurnCopyWithImpl(_UTurn _value, $Res Function(_UTurn) _then)
      : super(_value, (v) => _then(v as _UTurn));

  @override
  _UTurn get _value => super._value as _UTurn;
}

/// @nodoc
class _$_UTurn implements _UTurn {
  const _$_UTurn();

  @override
  String toString() {
    return 'InstructionType.uTurn()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _UTurn);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result left(),
    @required Result right(),
    @required Result sharpLeft(),
    @required Result sharpRight(),
    @required Result slightLeft(),
    @required Result slightRight(),
    @required Result straight(),
    @required Result enterRoundabout(),
    @required Result exitRoundabout(),
    @required Result uTurn(),
    @required Result goal(),
    @required Result depart(),
    @required Result keepLeft(),
    @required Result keepRight(),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return uTurn();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result left(),
    Result right(),
    Result sharpLeft(),
    Result sharpRight(),
    Result slightLeft(),
    Result slightRight(),
    Result straight(),
    Result enterRoundabout(),
    Result exitRoundabout(),
    Result uTurn(),
    Result goal(),
    Result depart(),
    Result keepLeft(),
    Result keepRight(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (uTurn != null) {
      return uTurn();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result left(_Left value),
    @required Result right(_Right value),
    @required Result sharpLeft(_SharpLeft value),
    @required Result sharpRight(_SharpRight value),
    @required Result slightLeft(_SlightLeft value),
    @required Result slightRight(_SlightRight value),
    @required Result straight(_Straight value),
    @required Result enterRoundabout(_EnterRoundabout value),
    @required Result exitRoundabout(_ExitRoundabout value),
    @required Result uTurn(_UTurn value),
    @required Result goal(_Goal value),
    @required Result depart(_Depart value),
    @required Result keepLeft(_KeepLeft value),
    @required Result keepRight(_KeepRight value),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return uTurn(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result left(_Left value),
    Result right(_Right value),
    Result sharpLeft(_SharpLeft value),
    Result sharpRight(_SharpRight value),
    Result slightLeft(_SlightLeft value),
    Result slightRight(_SlightRight value),
    Result straight(_Straight value),
    Result enterRoundabout(_EnterRoundabout value),
    Result exitRoundabout(_ExitRoundabout value),
    Result uTurn(_UTurn value),
    Result goal(_Goal value),
    Result depart(_Depart value),
    Result keepLeft(_KeepLeft value),
    Result keepRight(_KeepRight value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (uTurn != null) {
      return uTurn(this);
    }
    return orElse();
  }
}

abstract class _UTurn implements InstructionType {
  const factory _UTurn() = _$_UTurn;
}

/// @nodoc
abstract class _$GoalCopyWith<$Res> {
  factory _$GoalCopyWith(_Goal value, $Res Function(_Goal) then) =
      __$GoalCopyWithImpl<$Res>;
}

/// @nodoc
class __$GoalCopyWithImpl<$Res> extends _$InstructionTypeCopyWithImpl<$Res>
    implements _$GoalCopyWith<$Res> {
  __$GoalCopyWithImpl(_Goal _value, $Res Function(_Goal) _then)
      : super(_value, (v) => _then(v as _Goal));

  @override
  _Goal get _value => super._value as _Goal;
}

/// @nodoc
class _$_Goal implements _Goal {
  const _$_Goal();

  @override
  String toString() {
    return 'InstructionType.goal()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Goal);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result left(),
    @required Result right(),
    @required Result sharpLeft(),
    @required Result sharpRight(),
    @required Result slightLeft(),
    @required Result slightRight(),
    @required Result straight(),
    @required Result enterRoundabout(),
    @required Result exitRoundabout(),
    @required Result uTurn(),
    @required Result goal(),
    @required Result depart(),
    @required Result keepLeft(),
    @required Result keepRight(),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return goal();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result left(),
    Result right(),
    Result sharpLeft(),
    Result sharpRight(),
    Result slightLeft(),
    Result slightRight(),
    Result straight(),
    Result enterRoundabout(),
    Result exitRoundabout(),
    Result uTurn(),
    Result goal(),
    Result depart(),
    Result keepLeft(),
    Result keepRight(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (goal != null) {
      return goal();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result left(_Left value),
    @required Result right(_Right value),
    @required Result sharpLeft(_SharpLeft value),
    @required Result sharpRight(_SharpRight value),
    @required Result slightLeft(_SlightLeft value),
    @required Result slightRight(_SlightRight value),
    @required Result straight(_Straight value),
    @required Result enterRoundabout(_EnterRoundabout value),
    @required Result exitRoundabout(_ExitRoundabout value),
    @required Result uTurn(_UTurn value),
    @required Result goal(_Goal value),
    @required Result depart(_Depart value),
    @required Result keepLeft(_KeepLeft value),
    @required Result keepRight(_KeepRight value),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return goal(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result left(_Left value),
    Result right(_Right value),
    Result sharpLeft(_SharpLeft value),
    Result sharpRight(_SharpRight value),
    Result slightLeft(_SlightLeft value),
    Result slightRight(_SlightRight value),
    Result straight(_Straight value),
    Result enterRoundabout(_EnterRoundabout value),
    Result exitRoundabout(_ExitRoundabout value),
    Result uTurn(_UTurn value),
    Result goal(_Goal value),
    Result depart(_Depart value),
    Result keepLeft(_KeepLeft value),
    Result keepRight(_KeepRight value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (goal != null) {
      return goal(this);
    }
    return orElse();
  }
}

abstract class _Goal implements InstructionType {
  const factory _Goal() = _$_Goal;
}

/// @nodoc
abstract class _$DepartCopyWith<$Res> {
  factory _$DepartCopyWith(_Depart value, $Res Function(_Depart) then) =
      __$DepartCopyWithImpl<$Res>;
}

/// @nodoc
class __$DepartCopyWithImpl<$Res> extends _$InstructionTypeCopyWithImpl<$Res>
    implements _$DepartCopyWith<$Res> {
  __$DepartCopyWithImpl(_Depart _value, $Res Function(_Depart) _then)
      : super(_value, (v) => _then(v as _Depart));

  @override
  _Depart get _value => super._value as _Depart;
}

/// @nodoc
class _$_Depart implements _Depart {
  const _$_Depart();

  @override
  String toString() {
    return 'InstructionType.depart()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Depart);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result left(),
    @required Result right(),
    @required Result sharpLeft(),
    @required Result sharpRight(),
    @required Result slightLeft(),
    @required Result slightRight(),
    @required Result straight(),
    @required Result enterRoundabout(),
    @required Result exitRoundabout(),
    @required Result uTurn(),
    @required Result goal(),
    @required Result depart(),
    @required Result keepLeft(),
    @required Result keepRight(),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return depart();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result left(),
    Result right(),
    Result sharpLeft(),
    Result sharpRight(),
    Result slightLeft(),
    Result slightRight(),
    Result straight(),
    Result enterRoundabout(),
    Result exitRoundabout(),
    Result uTurn(),
    Result goal(),
    Result depart(),
    Result keepLeft(),
    Result keepRight(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (depart != null) {
      return depart();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result left(_Left value),
    @required Result right(_Right value),
    @required Result sharpLeft(_SharpLeft value),
    @required Result sharpRight(_SharpRight value),
    @required Result slightLeft(_SlightLeft value),
    @required Result slightRight(_SlightRight value),
    @required Result straight(_Straight value),
    @required Result enterRoundabout(_EnterRoundabout value),
    @required Result exitRoundabout(_ExitRoundabout value),
    @required Result uTurn(_UTurn value),
    @required Result goal(_Goal value),
    @required Result depart(_Depart value),
    @required Result keepLeft(_KeepLeft value),
    @required Result keepRight(_KeepRight value),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return depart(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result left(_Left value),
    Result right(_Right value),
    Result sharpLeft(_SharpLeft value),
    Result sharpRight(_SharpRight value),
    Result slightLeft(_SlightLeft value),
    Result slightRight(_SlightRight value),
    Result straight(_Straight value),
    Result enterRoundabout(_EnterRoundabout value),
    Result exitRoundabout(_ExitRoundabout value),
    Result uTurn(_UTurn value),
    Result goal(_Goal value),
    Result depart(_Depart value),
    Result keepLeft(_KeepLeft value),
    Result keepRight(_KeepRight value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (depart != null) {
      return depart(this);
    }
    return orElse();
  }
}

abstract class _Depart implements InstructionType {
  const factory _Depart() = _$_Depart;
}

/// @nodoc
abstract class _$KeepLeftCopyWith<$Res> {
  factory _$KeepLeftCopyWith(_KeepLeft value, $Res Function(_KeepLeft) then) =
      __$KeepLeftCopyWithImpl<$Res>;
}

/// @nodoc
class __$KeepLeftCopyWithImpl<$Res> extends _$InstructionTypeCopyWithImpl<$Res>
    implements _$KeepLeftCopyWith<$Res> {
  __$KeepLeftCopyWithImpl(_KeepLeft _value, $Res Function(_KeepLeft) _then)
      : super(_value, (v) => _then(v as _KeepLeft));

  @override
  _KeepLeft get _value => super._value as _KeepLeft;
}

/// @nodoc
class _$_KeepLeft implements _KeepLeft {
  const _$_KeepLeft();

  @override
  String toString() {
    return 'InstructionType.keepLeft()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _KeepLeft);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result left(),
    @required Result right(),
    @required Result sharpLeft(),
    @required Result sharpRight(),
    @required Result slightLeft(),
    @required Result slightRight(),
    @required Result straight(),
    @required Result enterRoundabout(),
    @required Result exitRoundabout(),
    @required Result uTurn(),
    @required Result goal(),
    @required Result depart(),
    @required Result keepLeft(),
    @required Result keepRight(),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return keepLeft();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result left(),
    Result right(),
    Result sharpLeft(),
    Result sharpRight(),
    Result slightLeft(),
    Result slightRight(),
    Result straight(),
    Result enterRoundabout(),
    Result exitRoundabout(),
    Result uTurn(),
    Result goal(),
    Result depart(),
    Result keepLeft(),
    Result keepRight(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (keepLeft != null) {
      return keepLeft();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result left(_Left value),
    @required Result right(_Right value),
    @required Result sharpLeft(_SharpLeft value),
    @required Result sharpRight(_SharpRight value),
    @required Result slightLeft(_SlightLeft value),
    @required Result slightRight(_SlightRight value),
    @required Result straight(_Straight value),
    @required Result enterRoundabout(_EnterRoundabout value),
    @required Result exitRoundabout(_ExitRoundabout value),
    @required Result uTurn(_UTurn value),
    @required Result goal(_Goal value),
    @required Result depart(_Depart value),
    @required Result keepLeft(_KeepLeft value),
    @required Result keepRight(_KeepRight value),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return keepLeft(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result left(_Left value),
    Result right(_Right value),
    Result sharpLeft(_SharpLeft value),
    Result sharpRight(_SharpRight value),
    Result slightLeft(_SlightLeft value),
    Result slightRight(_SlightRight value),
    Result straight(_Straight value),
    Result enterRoundabout(_EnterRoundabout value),
    Result exitRoundabout(_ExitRoundabout value),
    Result uTurn(_UTurn value),
    Result goal(_Goal value),
    Result depart(_Depart value),
    Result keepLeft(_KeepLeft value),
    Result keepRight(_KeepRight value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (keepLeft != null) {
      return keepLeft(this);
    }
    return orElse();
  }
}

abstract class _KeepLeft implements InstructionType {
  const factory _KeepLeft() = _$_KeepLeft;
}

/// @nodoc
abstract class _$KeepRightCopyWith<$Res> {
  factory _$KeepRightCopyWith(
          _KeepRight value, $Res Function(_KeepRight) then) =
      __$KeepRightCopyWithImpl<$Res>;
}

/// @nodoc
class __$KeepRightCopyWithImpl<$Res> extends _$InstructionTypeCopyWithImpl<$Res>
    implements _$KeepRightCopyWith<$Res> {
  __$KeepRightCopyWithImpl(_KeepRight _value, $Res Function(_KeepRight) _then)
      : super(_value, (v) => _then(v as _KeepRight));

  @override
  _KeepRight get _value => super._value as _KeepRight;
}

/// @nodoc
class _$_KeepRight implements _KeepRight {
  const _$_KeepRight();

  @override
  String toString() {
    return 'InstructionType.keepRight()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _KeepRight);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result left(),
    @required Result right(),
    @required Result sharpLeft(),
    @required Result sharpRight(),
    @required Result slightLeft(),
    @required Result slightRight(),
    @required Result straight(),
    @required Result enterRoundabout(),
    @required Result exitRoundabout(),
    @required Result uTurn(),
    @required Result goal(),
    @required Result depart(),
    @required Result keepLeft(),
    @required Result keepRight(),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return keepRight();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result left(),
    Result right(),
    Result sharpLeft(),
    Result sharpRight(),
    Result slightLeft(),
    Result slightRight(),
    Result straight(),
    Result enterRoundabout(),
    Result exitRoundabout(),
    Result uTurn(),
    Result goal(),
    Result depart(),
    Result keepLeft(),
    Result keepRight(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (keepRight != null) {
      return keepRight();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result left(_Left value),
    @required Result right(_Right value),
    @required Result sharpLeft(_SharpLeft value),
    @required Result sharpRight(_SharpRight value),
    @required Result slightLeft(_SlightLeft value),
    @required Result slightRight(_SlightRight value),
    @required Result straight(_Straight value),
    @required Result enterRoundabout(_EnterRoundabout value),
    @required Result exitRoundabout(_ExitRoundabout value),
    @required Result uTurn(_UTurn value),
    @required Result goal(_Goal value),
    @required Result depart(_Depart value),
    @required Result keepLeft(_KeepLeft value),
    @required Result keepRight(_KeepRight value),
  }) {
    assert(left != null);
    assert(right != null);
    assert(sharpLeft != null);
    assert(sharpRight != null);
    assert(slightLeft != null);
    assert(slightRight != null);
    assert(straight != null);
    assert(enterRoundabout != null);
    assert(exitRoundabout != null);
    assert(uTurn != null);
    assert(goal != null);
    assert(depart != null);
    assert(keepLeft != null);
    assert(keepRight != null);
    return keepRight(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result left(_Left value),
    Result right(_Right value),
    Result sharpLeft(_SharpLeft value),
    Result sharpRight(_SharpRight value),
    Result slightLeft(_SlightLeft value),
    Result slightRight(_SlightRight value),
    Result straight(_Straight value),
    Result enterRoundabout(_EnterRoundabout value),
    Result exitRoundabout(_ExitRoundabout value),
    Result uTurn(_UTurn value),
    Result goal(_Goal value),
    Result depart(_Depart value),
    Result keepLeft(_KeepLeft value),
    Result keepRight(_KeepRight value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (keepRight != null) {
      return keepRight(this);
    }
    return orElse();
  }
}

abstract class _KeepRight implements InstructionType {
  const factory _KeepRight() = _$_KeepRight;
}
